/// @title Sandwich contract
object "Sandwich" {
  // Constructor
  code {
    // constructor(address owner)
    // saves owner into bytecode (IMMUTABLE VARIABLE)
    // no SLOAD
    codecopy(datasize("Runtime"), sub(codesize(), 32), 32)

    // copy runtime code
    datacopy(0, dataoffset("Runtime"), datasize("Runtime"))

    // return runtime code and shoehorned immutable variable
    return(0, add(datasize("Runtime"), 32))
  }

  // Runtime code
  object "Runtime" {
    code {
      const _calldata := 128 // free memory pointer

      const _erc20_xfer_sig := 0xa9059cbb

      // Extract out IMMUTABLE VARIABLE owner
      datacopy(0, datasize("Runtime"), 32)
      let owner := mload(0)

      // Not owner? Revert, but still (3, 3) wgmi I guess
      if iszero(eq(caller(), owner)) {
        revert (3, 3)
      }

      // Check function sigs
      calldatacopy(_calldata, 0, calldatasize())
      switch mslice(_calldata, 4)

      case sig"recoverERC20(address token, uint256 balance)" {
        mstruct recoverERC20Calldata(sig: 4, token: 32, balance: 32)

        // mstore left pads zeros
        // so we need to start from 252 when doing call
        // 224 + 32 - 4
        mstore(224, _erc20_xfer_sig)

        // transfer(address recipient, uint256 amount)
        mstore(256, owner)
        mstore(288, recoverERC20Calldata.balance(_calldata))

        // Do the call
        require(
          call(
            gas(),
            recoverERC20Calldata.token(_calldata), // Target
            0,   // Value
            252, // Memory offset 224 + 28
            68,  // Length        4 + 32 + 32
            224,   // Return offset
            32    // Return length
          ),
          error"call"
        )

        return (0, 0)
      }

      // Sandwich
      default {
        // No function sig, boom
        mstruct sandwichCalldata(
          token: 20,
          pair: 20,
          amountIn: 16,
          amountOut: 16,
          tokenOut: 1
        )

        return (3, 3)
      }
    }
  }
}
